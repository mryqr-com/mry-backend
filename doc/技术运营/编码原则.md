- 检查console和client端哪些page需要及时加载，哪些是可以prefetch的
- 检查哪些页面需要client-loaded-indicator
- 对于acess denied，error等公用页面，考虑console端和client端公用的可能性
- 重命名时，如果名称与先前的一样，则不能检查重复性
- 检查各个聚合根哪些字段不能重复，并看代码中是否有对此的支持
- 检查前端router，哪些地方用push，哪些地方用replace
- 所有聚合根加上opslog，opslog中应该加上简要的上下文信息，并且以句号结尾。
- 后端检查所有重要日志，包括正常节点，以及重要的错误，警告节点
- 前端检查所有弹出框使用【】符号
- 前端message box使用【】符号
- API测试需要专门测试EDA
- 重命名资源时，如果名字没变，则不再继续操作
- 对于非GET请求，API测试需要专门测试权限
- 统一检查每个ErrorCode所对应的status code是否合理
- 检查使用repo.byIds及其变种的各个地方，到底应该采用哪个变种
- 当queryService不经过ar直接从db读数据时，需要制定include的字段，这样更高效
- 后端不能有@Deprecated存在
- API测试时，每个Controller具有自己的XXXApi，该API只负责自身功能，如果需要同时调用多个API，则需要在CompositeApi中定义
- API测试正常情况下优先使用XXXApi，而不使用底层的RestAssured，只有在验证异常时才使用底层的RestAssured
- 对于MongoDB的findOne()，如果query中的字段可以为null，那么传入null时将始终返回数据库中第一个记录，维系需要对查询字段做null判断
- 前端检查：有些不需要浏览器自动填充的密码，但是却自动填充了，需要做处理
- 后端：只有repository,calculator,Task和QueryService可以反问MongoTemplate,所操作的collection对应哪个聚合根，则放到对应聚合根的Reposiutory或者DAO中
- Mry中的事件架构主要用于处理数据同步，需要保证事件可以被反复消费
- EventHandler主要起orchestration的作用，真正完成功能是各种Task，Task应该保证可以独立运行，且多次运行不会对系统造成错误
- Task更新的是哪个聚合根，就将该Task放在这个聚合根对应的package下
- 所有异常信息和出错信息均需要加上句号，并且是一句通顺的话。
- mongotemplate能用类的class则用，尽量不要使用collection的字符串名称
- 在用MongoTemplate查询时，需要注意条件值为null的情况，因为为null时整个条件都不会生效，而不是查询对应字段为null值
- 前端：显示的message需要加上句号
- 前端：访问后端API时需要决定是否需要加上return，因为加上return后可以通过统一的方式处理异常
- 后端，所有引用mongoTemplate的类均需要对方法参数进行非空判断
- 不管使用哪个地图（百度，高德，天地图），整个系统都使用gcj02坐标系对经纬度进行存储
- 后端repository中的缓存只能有queryservice直接调用
- 对AR的写操作不要使用该AR的缓存
- 对AR的管理性读操作不要使用该AR的缓存